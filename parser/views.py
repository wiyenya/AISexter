from django.shortcuts import render, redirect
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.db.models import Count, Max
from collections import defaultdict
import asyncio
import threading
from .models import Profile, ChatMessage, ModelInfo, FullChatMessage
from .services import ChatParser, OctoAPIClient, OctoClient
from django.conf import settings


def chat_parser_view(request):
    """–í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –ø–∞—Ä—Å–µ—Ä–∞ —á–∞—Ç–æ–≤"""
    # –ü–æ–ª—É—á–∞–µ–º –º–æ–¥–µ–ª–∏ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã ModelInfo
    try:
        model_infos = ModelInfo.objects.all()
        
        # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π –¥–ª—è –≤—ã–±–æ—Ä–∞
        profiles = []
        for model_info in model_infos:
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –º–æ–¥–µ–ª–∏ –±–µ–∑ UUID –ø—Ä–æ—Ñ–∏–ª—è OctoBrowser
            if not model_info.model_octo_profile:
                continue
                
            profiles.append({
                'uuid': model_info.model_octo_profile,  # UUID –∏–∑ model_octo_profile
                'title': model_info.model_name,          # –ò–º—è –º–æ–¥–µ–ª–∏
                'name': model_info.model_name,
                'model_id': model_info.model_id          # ID –º–æ–¥–µ–ª–∏ –¥–ª—è —Å–≤—è–∑–∏
            })
            
    except Exception as e:
        print(f"Error getting models from ModelInfo: {e}")
        profiles = []
    
    # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–µ —á–∞—Ç—ã –∏–∑ FullChatMessage, —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ –º–æ–¥–µ–ª—è–º
    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ model_id –∏ user_id (user_id = –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞)
    all_chats = FullChatMessage.objects.values(
        'model_id',
        'user_id',
    ).annotate(
        message_count=Count('id'),
        last_message_date=Max('timestamp')
    ).order_by('model_id', '-last_message_date')
    
    # –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Å–≤—è–∑–∏ model_id —Å –∏–º–µ–Ω–∞–º–∏ –º–æ–¥–µ–ª–µ–π –∏–∑ ModelInfo
    model_infos_dict = {m.model_id: m.model_name for m in ModelInfo.objects.all()}
    
    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —á–∞—Ç—ã –ø–æ –º–æ–¥–µ–ª—è–º
    models_with_chats = defaultdict(lambda: {
        'model_name': '',
        'model_id': '',
        'chats': [],
        'total_messages': 0,
        'last_activity': None
    })
    
    for chat in all_chats:
        model_id = chat['model_id'] or 'unknown'
        model_name = model_infos_dict.get(model_id, f'Model {model_id}')
        
        models_with_chats[model_id]['model_name'] = model_name
        models_with_chats[model_id]['model_id'] = model_id
        models_with_chats[model_id]['chats'].append({
            'user_id': chat['user_id'],
            'message_count': chat['message_count'],
            'last_message': chat['last_message_date'],
            'chat_id': chat['user_id']  # –ò—Å–ø–æ–ª—å–∑—É–µ–º user_id –∫–∞–∫ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞
        })
        models_with_chats[model_id]['total_messages'] += chat['message_count']
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
        if models_with_chats[model_id]['last_activity'] is None or \
           (chat['last_message_date'] and chat['last_message_date'] > models_with_chats[model_id]['last_activity']):
            models_with_chats[model_id]['last_activity'] = chat['last_message_date']
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥–µ–ª–∏ –ø–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    sorted_models = sorted(
        models_with_chats.values(),
        key=lambda x: x['last_activity'] if x['last_activity'] else '',
        reverse=True
    )
    
    context = {
        'profiles': profiles,
        'models_with_chats': sorted_models
    }
    
    if request.method == 'POST':
        profile_uuid = request.POST.get('profile')
        chat_url = request.POST.get('chat_url')
        
        if not profile_uuid or not chat_url:
            context['error'] = 'Please select a profile and enter a chat URL'
            return render(request, 'parser/chat_parser.html', context)
        
        try:
            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—Å–µ—Ä –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            import logging
            import traceback
            logger = logging.getLogger(__name__)
            
            def run_parser():
                try:
                    logger.info(f"üöÄ Starting ChatParser for profile {profile_uuid} and URL {chat_url}")
                    print(f"üöÄ Starting ChatParser for profile {profile_uuid} and URL {chat_url}")
                    parser = ChatParser(profile_uuid, chat_url)
                    result = asyncio.run(parser.run())
                    logger.info(f"‚úÖ Parser finished with result: {result}")
                    print(f"‚úÖ Parser finished with result: {result}")
                except Exception as e:
                    logger.error(f"‚ùå Parser error: {e}", exc_info=True)
                    print(f"‚ùå Parser error: {e}")
                    traceback.print_exc()
            
            thread = threading.Thread(target=run_parser, name=f"ChatParser-{profile_uuid[:8]}")
            thread.daemon = True
            thread.start()
            
            logger.info(f"‚úÖ Thread started: {thread.name}")
            print(f"‚úÖ Thread started: {thread.name}")
            
            context['success'] = f'Chat parsing started for {chat_url}. Check logs: docker-compose logs -f web'
            
        except Exception as e:
            context['error'] = f'Error starting parser: {str(e)}'
            print(f"Error starting parser thread: {e}")
    
    return render(request, 'parser/chat_parser.html', context)


@csrf_exempt
@require_http_methods(["POST"])
def stop_chat_parsing(request):
    """API endpoint –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞ —á–∞—Ç–∞"""
    try:
        profile_uuid = request.POST.get('profile_uuid')
        
        if not profile_uuid:
            return JsonResponse({'status': 'error', 'message': 'Missing profile_uuid'})
        
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å –≤ Octo Browser
        octo = OctoClient.init_from_settings()
        success = octo.stop_profile(profile_uuid)
        
        if success:
            return JsonResponse({
                'status': 'success', 
                'message': f'Chat parsing stopped for profile {profile_uuid}'
            })
        else:
            return JsonResponse({
                'status': 'error', 
                'message': 'Failed to stop profile'
            })
        
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)})


@csrf_exempt
@require_http_methods(["POST"])
def start_chat_parsing(request):
    """API endpoint –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —á–∞—Ç–∞"""
    try:
        profile_uuid = request.POST.get('profile_uuid')
        chat_url = request.POST.get('chat_url')
        
        if not profile_uuid or not chat_url:
            return JsonResponse({'status': 'error', 'message': 'Missing required parameters'})
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—Å–µ—Ä –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        def run_parser():
            try:
                parser = ChatParser(profile_uuid, chat_url)
                asyncio.run(parser.run())
            except Exception as e:
                print(f"Parser error: {e}")
        
        thread = threading.Thread(target=run_parser)
        thread.daemon = True
        thread.start()
        
        return JsonResponse({
            'status': 'success', 
            'message': f'Chat parsing started'
        })
        
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)})


def view_chat_messages(request, profile_id):
    """–ü—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —á–∞—Ç–∞"""
    chat_url = request.GET.get('chat_url')
    
    if not chat_url:
        context = {'error': 'Chat URL is required'}
        return render(request, 'parser/chat_parser.html', context)
    
    try:
        profile = Profile.objects.get(id=profile_id)
        chat_messages = ChatMessage.objects.filter(
            profile=profile,
            chat_url=chat_url
        ).order_by('message_date', 'created_at')
        
        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        total_messages = chat_messages.count()
        model_messages = chat_messages.filter(is_from_model=True).count()
        user_messages = total_messages - model_messages
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–≤—É—é –∏ –ø–æ—Å–ª–µ–¥–Ω—é—é –¥–∞—Ç—É —Å–æ–æ–±—â–µ–Ω–∏–π
        first_message = chat_messages.first()
        last_message = chat_messages.last()
        
        context = {
            'profile': profile,
            'chat_url': chat_url,
            'messages': chat_messages,
            'total_messages': total_messages,
            'model_messages': model_messages,
            'user_messages': user_messages,
            'first_message_date': first_message.message_date if first_message else None,
            'last_message_date': last_message.message_date if last_message else None,
        }
        
        return render(request, 'parser/view_chat.html', context)
        
    except Profile.DoesNotExist:
        context = {'error': 'Profile not found'}
        return render(request, 'parser/chat_parser.html', context)


def view_full_chat(request):
    """–ü—Ä–æ—Å–º–æ—Ç—Ä –¥–∏–∞–ª–æ–≥–∞ –∏–∑ FullChatMessage –ø–æ user_id –∏ model_id"""
    user_id = request.GET.get('user_id')
    model_id = request.GET.get('model_id')
    
    if not user_id or not model_id:
        context = {'error': 'user_id and model_id are required'}
        return render(request, 'parser/chat_parser.html', context)
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —á–∞—Ç–∞
        messages = FullChatMessage.objects.filter(
            user_id=user_id,
            model_id=model_id
        ).order_by('timestamp')
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–æ–¥–µ–ª–∏
        try:
            model_info = ModelInfo.objects.get(model_id=model_id)
            model_name = model_info.model_name
        except ModelInfo.DoesNotExist:
            model_name = f'Model {model_id}'
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        total_messages = messages.count()
        model_messages = messages.filter(is_from_model=True).count()
        user_messages = messages.filter(is_from_model=False).count()
        
        # –ü–µ—Ä–≤–æ–µ –∏ –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        first_message = messages.first()
        last_message = messages.last()
        
        # URL —á–∞—Ç–∞
        chat_url = f"https://onlyfans.com/my/chats/chat/{user_id}/"
        
        context = {
            'user_id': user_id,
            'model_id': model_id,
            'model_name': model_name,
            'messages': messages,
            'chat_url': chat_url,
            'total_messages': total_messages,
            'model_messages': model_messages,
            'user_messages': user_messages,
            'first_message_date': first_message.timestamp if first_message else None,
            'last_message_date': last_message.timestamp if last_message else None,
        }
        
        return render(request, 'parser/view_full_chat.html', context)
        
    except Exception as e:
        context = {'error': f'Error loading chat: {str(e)}'}
        return render(request, 'parser/chat_parser.html', context)


@csrf_exempt
@require_http_methods(["GET"])
def get_active_parsers(request):
    """API endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–∞—Ä—Å–µ—Ä–æ–≤"""
    try:
        octo = OctoClient.init_from_settings()
        running_profiles = octo.get_running_profiles()
        
        # –ü–æ–ª—É—á–∞–µ–º UUID –ø—Ä–æ—Ñ–∏–ª–µ–π –∏–∑ ModelInfo
        model_infos = ModelInfo.objects.exclude(model_octo_profile__isnull=True).exclude(model_octo_profile='')
        model_uuid_to_name = {m.model_octo_profile: m.model_name for m in model_infos}
        chat_parser_uuids = list(model_uuid_to_name.keys())
        
        active_parsers = []
        for profile in running_profiles:
            profile_uuid = profile.get('uuid')
            if profile_uuid in chat_parser_uuids:
                active_parsers.append({
                    'uuid': profile_uuid,
                    'name': model_uuid_to_name.get(profile_uuid, profile.get('title', 'Unknown')),
                    'status': 'running'
                })
        
        return JsonResponse({
            'status': 'success',
            'active_parsers': active_parsers
        })
        
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)})


@csrf_exempt
@require_http_methods(["POST"])
def stop_all_parsers(request):
    """API endpoint –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–∞—Ä—Å–µ—Ä–æ–≤"""
    try:
        octo = OctoClient.init_from_settings()
        running_profiles = octo.get_running_profiles()
        
        # –ü–æ–ª—É—á–∞–µ–º UUID –ø—Ä–æ—Ñ–∏–ª–µ–π –∏–∑ ModelInfo
        model_infos = ModelInfo.objects.exclude(model_octo_profile__isnull=True).exclude(model_octo_profile='')
        model_uuid_to_name = {m.model_octo_profile: m.model_name for m in model_infos}
        chat_parser_uuids = list(model_uuid_to_name.keys())
        
        stopped_count = 0
        errors = []
        
        for profile in running_profiles:
            profile_uuid = profile.get('uuid')
            if profile_uuid in chat_parser_uuids:
                try:
                    success = octo.stop_profile(profile_uuid)
                    if success:
                        stopped_count += 1
                    else:
                        profile_name = model_uuid_to_name.get(profile_uuid, profile.get('title', 'Unknown'))
                        errors.append(f"Failed to stop {profile_name}")
                except Exception as e:
                    profile_name = model_uuid_to_name.get(profile_uuid, profile.get('title', 'Unknown'))
                    errors.append(f"Error stopping {profile_name}: {str(e)}")
        
        return JsonResponse({
            'status': 'success',
            'stopped_count': stopped_count,
            'errors': errors
        })
        
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)})

